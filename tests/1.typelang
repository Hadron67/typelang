module Eq: [n, T: Type(n)] -> T -> T -> Type(n) {
    refl: [n, T: Type(n)](x: T) -> Self(x, x);

    inv: [n, T: Type(n), x: T, y] -> Self(x, y) -> Self(y, x);
    inv(refl(?)) = refl(_);

    concat: [n, T: Type(n), x: T, y, z] -> Self(x, y) -> Self(y, z) -> Self(x, z);
    concat(refl(?x), refl(?x)) = refl(_);

    transport: [n, n', T: Type(n), x: T, y](P: T -> Type(n')) -> Self(x, y) -> P(x) -> P(y);
    transport(?, refl(?), ?p0) = p0;

    transportconst: [n, n', A: Type(n), B: Type(n'), x: A, y](p: Self(x, y), b: B) -> Self(transport(\_ B, p, b), b);
    transportconst(refl(?x), ?b) = refl(b);

    ap: [n, n', A: Type(n), B: Type(n'), x: A, y](f: A -> B, p: Self(x, y)) -> Self(f(x), f(y));
    ap(?, refl(?)) = refl(_);

    apd: [n, n', A: Type(n), B: A -> Type(n'), x: A, y](f: (x: A) -> B(x), p: Self(x, y)) -> Self(transport(B, p, f(x)), f(y));
    apd(?, refl(?)) = refl(_);

    module lemma-2-1-4 {
        l1: [n, A: Type(n), x: A, y](p: Eq(x, y)) -> Eq(p, concat(p, refl(y)));
        l1(refl(?)) = refl(_);

        l2-1: [n, A: Type(n), x: A, y](p: Eq(x, y)) -> Eq(concat(p, inv(p)), refl(x));
        l2-1(refl(?)) = refl(_);

        l2-2: [n, A: Type(n), x: A, y](p: Eq(x, y)) -> Eq(concat(inv(p), p), refl(y));
        l2-2(refl(?)) = refl(_);
    }

    lemma-2-3-8: [n, n', A: Type(n), B: Type(n'), x: A, y](f: A -> B, p: Self(x, y)) -> Self(apd(f, p), concat(transportconst(p, f(x)), ap(f, p)));
    lemma-2-3-8(?, refl(?)) = refl(_);

    lemma-2-3-9: [n, n', A: Type(n), P: A -> Type(n'), x: A, y: A, z, u: P(x)](p: Self(x, y), q: Self(y, z)) -> Self(transport(P, q, transport(P, p, u)), transport(P, concat(p, q), u));
    lemma-2-3-9(refl(?x), refl(?x)) = refl(_);

    lemma-2-3-10: [n1, n2, n3, A: Type(n1), B: Type(n2), f: A -> B, P: B -> Type(n3), x: A, y](p: Self(x, y), u: P(f(x))) -> Self(transport(\x P(f(x)), p, u), transport(P, ap(f, p), u));
    lemma-2-3-10(refl(?), ?) = refl(_);

    lemma-2-3-11: [n, n1, n2, A: Type(n), P: A -> Type(n1), Q: A -> Type(n2), f: (x: A) -> P(x) -> Q(x), x: A, y](p: Self(x, y), u: P(x)) -> Self(transport(Q, p, f(x, u)), f(y, transport(P, p, u)));
    lemma-2-3-11(refl(?), ?) = refl(_);
}

module Sigma: [n, n'](A: Type(n)) -> (A -> Type(n')) -> Type(builtin.Level.max(n, n')) {
    pair: [n, n', A: Type(n), B: A -> Type(n')](a: A) -> B(a) -> Self(A, B);
    first: [n, n', A: Type(n), B: A -> Type(n')] -> Self(A, B) -> A;
    first(pair(?a, ?b)) = a;
    second: [n, n', A: Type(n), B: A -> Type(n')] -> (self: Self(A, B)) -> B(first(self));
    second(pair(?a, ?b)) = b;
}

module Nat: Type(0) {
    zero: Self;
    succ: Self -> Self;

    module plus: Nat -> Nat -> Nat {
        Self(?x, zero) = x;
        Self(?x, succ(?y)) = succ(plus(x, y));

        l1: (x: Nat) -> Eq(x, plus(zero, x));
        l1(zero) = Eq.refl(_);
        l1(succ(?x)) = Eq.ap(succ, l1(x));

        l2: (x: Nat, y: Nat) -> Eq(succ(plus(x, y)), plus(succ(x), y));
        l2(?x, zero) = Eq.refl(_);
        l2(?x, succ(?y)) = Eq.ap(succ, l2(x, y));

        commu: (x: Nat, y: Nat) -> Eq(plus(x, y), plus(y, x));
        commu(?x, zero) = l1(x);
        commu(?x, succ(?y)) = Eq.concat(Eq.ap(succ, commu(x, y)), l2(y, x));

        assoc: (x: Nat, y: Nat, z: Nat) -> Eq(plus(plus(x, y), z), plus(x, plus(y, z)));
        assoc(?x, ?y, zero) = Eq.refl(_);
        assoc(?x, ?y, succ(?z)) = Eq.ap(succ, assoc(x, y, z));
    }

    module mul: Nat -> Nat -> Nat {
        Self(?x, zero) = zero;
        Self(?x, succ(?y)) = plus(mul(x, y), x);

        l0: (x: Nat, y: Nat, z: Nat) -> Eq(plus(plus(x, y), z), plus(plus(x, z), y));
        l0(?x, ?y, ?z) = Eq.concat(Eq.concat(plus.assoc(x, y, z), Eq.ap(\y plus(x, y), plus.commu(y, z))), Eq.inv(plus.assoc(x, z, y)));

        l1: (x: Nat) -> Eq(zero, mul(zero, x));
        l1(zero) = Eq.refl(_);
        l1(succ(?x)) = l1(x);

        l2: (x: Nat, y: Nat) -> Eq(plus(mul(x, y), y), mul(succ(x), y));
        l2(?x, zero) = Eq.refl(_);
        l2(?x, succ(?y)) = Eq.ap(succ, Eq.concat(l0(mul(x, y), x, y), Eq.ap(\y plus(y, x), l1(x, y))));

        commu: (x: Nat, y: Nat) -> Eq(mul(x, y), mul(y, x));
        commu(?x, zero) = l1(x);
        commu(?x, succ(?y)) = Eq.concat(Eq.ap(\y plus(y, x), commu(x, y)), l2(y, x));

        distro: (x: Nat, y: Nat, z: Nat) -> Eq(mul(x, plus(y, z)), plus(mul(x, y), mul(x, z)));
        distro(?x, ?y, zero) = Eq.refl(_);
        distro(?x, ?y, succ(?z)) = Eq.concat(Eq.ap(\y plus(y, x), distro(x, y, z)), plus.assoc(mul(x, y), mul(x, z), x));

        assoc: (x: Nat, y: Nat, z: Nat) -> Eq(mul(mul(x, y), z), mul(x, mul(y, z)));
        assoc(?x, ?y, zero) = Eq.refl(_);
        assoc(?x, ?y, succ(?z)) = Eq.concat(Eq.ap(\z plus(z, mul(x, y)), assoc(x, y, z)), Eq.inv(distro(x, mul(y, z), y)));
    }

    module leq: Self -> Self -> Type(0) {
        Self(?n, ?m) = Sigma(Nat, \k Eq(plus(n, k), m));

        trans: [a: Nat, b: Nat, c: Nat] -> Self(a, b) -> Self(b, c) -> Self(a, c);
        trans[?a, ?b, ?c](Sigma.pair(?k1, ?p1), Sigma.pair(?k2, ?p2)) = Sigma.pair(plus(k1, k2), Eq.concat(Eq.inv(plus.assoc(a, k1, k2)), Eq.concat(Eq.ap(\y plus(y, k2), p1), p2)));
    }
}

module S1: Type(0) {
    base: Self;
    loop: Eq(base, base);

    module lemma-6-2-5 {
        f: [n, A: Type(n), a: A](p: Eq(a, a)) -> S1 -> A;
        f[?, ?, ?a](?p, base) = a;
        f-eq: [n, A: Type(n), a: A](p: Eq(a, a)) -> Eq(Eq.apd(f(p), loop), Eq.concat(Eq.transportconst(loop, a), p));
        col: [n, A: Type(n), a: A](p: Eq(a, a)) -> Eq(Eq.ap(f(p), loop), p);
    }
}

module Vec3: [n] -> Type(n) -> Type(n) {
    new: [n, T: Type(n)] -> T -> T -> T -> Self(T);
}

mkTest: Nat -> Nat -> Nat;
mkTest(?x, ?y) = Nat.plus(x, y);

typeof: [n, T: Type(n)] -> T -> Type(n);
typeof[?, ?T](?) = T;

test0: Eq(Nat, typeof(Nat.zero)) = Eq.refl(_);

module Option: [n] -> Type(n) -> Type(n) {
    none: [n](T: Type(n)) -> Self(T);
    some: [n, T: Type(n)] -> T -> Self(T);

    map: [n, n', T: Type(n), B: Type(n')] -> Self(T) -> (T -> B) -> Self(B);
    map(none(?), ?) = none(_);
    map(some(?x), ?f) = some(f(x));

    or: [n, T: Type(n)] -> Self(T) -> T -> T;
    or(none(?), ?a) = a;
    or(some(?x), ?) = x;

    and: [n, T: Type(n)] -> Self(T) -> Self(T) -> Self(T);
    and(none(?), ?x) = x;
    and(some(?x), ?) = some(x);
}

module List: [n] -> Type(n) -> Type(n) {
    empty: [n](T: Type(n)) -> Self(T);
    append: [n, T: Type(n)] -> Self(T) -> T -> Self(T);

    concat: [n, T: Type(n)] -> Self(T) -> Self(T) -> Self(T);
    concat(?l, empty(?)) = l;
    concat(?l, append(?l2, ?x)) = append(concat(l, l2), x);

    map: [n, n', T: Type(n), B: Type(n')] -> Self(T) -> (T -> B) -> Self(B);
    map(empty(?), ?) = empty(_);
    map(append(?s, ?x), ?f) = append(map(s, f), f(x));
}

module Array: [n] -> Nat -> Type(n) -> Type(n) {
    empty: [n](T: Type(n)) -> Self(Nat.zero, T);
    append: [n, T: Type(n), l: Nat] -> Self(l, T) -> T -> Self(Nat.succ(l), T);

    concat: [n, T: Type(n), l: Nat, l2: Nat] -> Self(l, T) -> Self(l2, T) -> Self(Nat.plus(l, l2), T);
    concat(?l, empty(?)) = l;
    concat(?l, append(?l2, ?x)) = append(concat(l, l2), x);
}

module Int: Type(0) {
    pos: Nat -> Self;
    neg: Nat -> Self;
}

module Empty: Type(0) {}

not: [n] -> Type(n) -> Type(n);
not(?a) = a -> Empty;

module logic {
    l1: [n, A: Type(n)] -> A -> not(not(A));
    l1(?a, ?f) = f(a);

    l2: [n, n', A: Type(n), B: Type(n')] -> (A -> B) -> (not(B) -> not(A));
    l2(?f, ?nb, ?a) = nb(f(a));

    l3: [n, A: Type(n)] -> not(not(not(A))) -> not(A);
    l3[?, ?A] = l2(l1[_, A]);
}

module cubical {
    I: Type(0);
    i0: I;
    i1: I;

    PathP: [n](A: I -> Type(n)) -> A(i0) -> A(i1) -> Type(n);
    as-fn: [n, A: I -> Type(n), x, y] -> PathP(A, x, y) -> (x: I) -> A(x);
    as-fn[?, ?, ?x, ?y](?, i0) = x;
    as-fn[?, ?, ?x, ?y](?, i1) = y;

    Path: [n, A: Type(n)] -> A -> A -> Type(n);
    Path[?, ?A] = PathP(\_ A);

    refl: [n, A: Type(n)](x: A) -> Path(x, x);
}
