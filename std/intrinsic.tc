embed: string -> Array(u8);

module bool {
    bool: Type(0);
    true: bool;
    false: bool;
    ind: [n, C: bool -> Type(n)] -> C(true) -> C(false) -> (x: bool) -> C(x);
}

module Nat {
    Self: Type(0);
    zero: Self;
    succ: Self -> Self;

    max: Self -> Self -> Self;
    max(x, zero) = x;
    max(x, succ(y)) = max-succ(y, x);

    max-succ: Self -> Self -> Self;
    max-succ(y, zero) = succ(y);
    max-succ(y, succ(x)) = succ(max(x, y));
}

module Bit {
    Self: Type(0);
}

module IntType {
    Self: Nat -> bool -> Type(0);
}

module FloatType {
    Self: Type(0);
    f32: Self;
    f64: Self;
    f128: Self;
}

module IsMachineType {
    Self: [n] -> Type(n) -> Type(n);
    int: [bits: Nat, const: bool](T: IntType(bist, const)) -> Self(T);
}

module Size {
    Self: Type(0);
    value: Nat -> Self;
    of: [n, T: Type(n)] -> IsMachineType(T) -> Self;

    ind: [n, C: Self -> Type(n)] -> ((x: Nat) -> value(x)) -> ([n, T: Type(n)](i: IsMachineType(T)) -> of(i)) -> (x: Self) -> C(x);
}

module Ptr {
    Self: [n] -> Type(n) -> bool -> Align -> Type(n);

    load: [n, T: Type(n), const, A] -> Self(T, const, A) -> T;
    store: [n, T: Type(n), A] -> Self(T, false, A) -> T -> void;

    module Align {
        Self: Type(0);
        specific: number -> Self;
        of: [n] -> Type(n) -> Self;
        max: Self;
    }
}

module Sum {
    Self: [m, n, A: Type(m)] -> (A -> Type(n)) -> Type(m.max(n));
    first: [m, n, A: Type(m), F: A -> Type(n)] -> Self(F) -> A;
    second: [m, n, A: Type(m), F: A -> Type(n)](self: Self(F)) -> F(first(self));
}
